---
layout: default
title: Home
---
<div class="hero-unit">
	<img class="logo" src="./images/logo.png" align="left">
	<h1>Signal/Collect</h1>
	<p>Allows you to process large graphs in seconds.</p>
	<p class="download-info">
	  <a href="https://github.com/uzh/signal-collect" class="btn btn-large">Project on GitHub</a>
	  <a href="gettingStarted.html" class="btn btn-primary btn-large">Get Started</a>
	</p>
</div>

<div class="row">
	<div class="span4">
	   <h2>Fast and scalable</h2>
	   <p>Algorithms are automatically executed in parallel.</p>
	</p>
	</div>
	<div class="span4">
	  <h2>Easy to use</h2>
	  <p>Many algorithms can be expressed in just a few lines of code.</p>
	</div>
	<div class="span4"> 
	  <h2>Configurable</h2><!-- Dynamic &amp; -->
	  <p>The defaults get you started quickly, but everything can be customized.</p>
	 <!-- Low-latency, incremental computation: Run your algorithms either synchronously or asynchronously and change the graph structure in real-time, without restarting the computation.</p> -->
	</div>
</div>

	  <hr class="soften">
          <h2>How it works</h2>
          <p>In Signal/Collect algorithms are written from the perspective of vertices and edges. Once a graph has been specified the edges will <b>signal</b> and the vertices will  <b>collect</b>. When an edge signals it computes a message based on the state of its source vertex. This message is then sent along the edge to the target vertex of the edge. When a vertex collects it uses the received messages to update its state. These operations happen in parallel all over the graph until all messages have been collected and all vertex states have converged.</p>
          <p>Many algorithms have very simple and elegant implementations in Signal/Collect. Please take the time to explore some of the example algorithms below.</p>

	  <hr class="soften">

        <div class="span9 columns">
          <h2>Example Algorithms</h2>
          <!--<p>Click the tabs below to toggle between different algorithms.</p>-->
          <ul id="tab" class="nav nav-tabs">
            <li class="active"><a href="#home" data-toggle="tab">PageRank</a></li>
            <li><a href="#profile" data-toggle="tab">Single-Source Shortest Path</a></li>
          </ul>
          <div id="myTabContent" class="tab-content">
            <div class="tab-pane fade in active" id="home">
<pre class="prettyprint linenums">
import com.signalcollect._

object PageRank extends App {
  val graph = GraphBuilder.build
  graph.addVertex(new PageRankVertex(1))
  graph.addVertex(new PageRankVertex(2))
  graph.addEdge(1, new PageRankEdge(2))
  graph.addEdge(2, new PageRankEdge(1))
  graph.execute
  graph.foreachVertex(println(_))
  graph.shutdown
}

class PageRankVertex(id: Int, baseRank: Double = 0.15)
    extends DataGraphVertex(id, baseRank) {
  type Signal = Double
  def dampingFactor = 1 - baseRank
  def collect = baseRank + dampingFactor * signals.sum
}

class PageRankEdge(targetId: Int)
    extends DefaultEdge(targetId) {
  type Source = PageRankVertex
  def signal = source.state * weight / source.sumOfOutWeights
}
</pre>
            </div>
            <div class="tab-pane fade" id="profile">
<pre class="prettyprint linenums">
import com.signalcollect._

object SSSP extends App {
  val graph = GraphBuilder.build
  graph.addVertex(new Location(1, Some(0)))
  graph.addVertex(new Location(2))
  graph.addVertex(new Location(3))
  graph.addEdge(1, new Path(2))
  graph.addEdge(2, new Path(3))
  graph.execute
  graph.foreachVertex(println(_))
  graph.shutdown
}

class Location(id: Int, initialState: Option[Int] = None)
	extends DataFlowVertex(id, initialState) {
  type Signal = Int
  def collect(signal: Int) = state match {
    case None                      => Some(signal)
    case Some(currentShortestPath) => Some(math.min(currentShortestPath, signal))
  }
}

class Path(t: Int) extends OptionalSignalEdge(t) {
  def signal = source.state match {
    case None                => None
    case Some(distance: Int) => Some(distance + weight.toInt)
  }
}
</pre>
            </div>
          </div>
